local DownloadFile = class('DownloadFile')
local CSHttpUtil = Util.Http
function DownloadFile:ctor(url, threadCount, savePath, cb, error)
    self.url = url
    self.savePath = savePath
    self.fileName = string.sub(savePath, string.rfind(savePath, '/') + 1, string.len(savePath))
    self.dirPath = string.gsub(savePath, self.fileName, '')
    self.size = nil
    self.tempSize = 0
    self.sizes = {}
    self.threadCount = threadCount or 10
    self.error = error
    self.tempFilePaths = {}
    ActionList:new():on(
        function(next)
            -- 读取文件尺寸
            self:getFileSizeAsyn(
                function(size)
                    self.size = size
                    next()
                end,
                function(ex)
                    print(string.format('读取文件大小出错 >>> url:%s message:%s', self.url, ex.Message))
                    if (self.error ~= nil) then
                        self.error(ex)
                    end
                end
            )
        end
    ):on(
        function(next)
            -- 准备工作
            -- 重算下载线程数 文件大小 配置等各种因素
            -- 保证每个线程最少的下载大小
            local threadMinSize = 0 * 1024 --KB
            self.threadCount =
                self.size / self.threadCount > threadMinSize and self.threadCount or
                math.ceil(self.size / threadMinSize)

            self.sizes = self:splitFileSize(self.size, self.threadCount)

            -- 临时文件
            for i = 1, self.threadCount do
                local filePath = string.format('%s%d.temp', self.savePath, i)
                print(filePath)
                table.insert(self.tempFilePaths, filePath)
            end
            -- 清理缓存文件
            local files = Util.File:GetChildFiles(self.dirPath, string.format('%s*.temp', self.fileName))

            for i = 0, files.Length - 1 do
                if (files.Length ~= self.threadCount) then
                    -- 临时文件存在问题 清理掉
                    Util.File:DeleteFileInfo(files:GetValue(i))
                else
                    self.tempSize = self.tempSize + Util.File:ReadBytes(self.tempFilePaths[i + 1]).Length
                end
            end
            next()
        end
    ):on(
        function(next)
            if (cb ~= nil) then
                cb(self)
            end
        end
    ):show()
end
function DownloadFile:Download(cb, downloading)
    local time = Time.time
    local downCount = 0
    local data = System.Collections.Generic.List_byte()
    local all_cb = function()
        for index = 1, self.threadCount do
            local tempFilePath = self.tempFilePaths[index]
            data:AddRange(Util.File:ReadBytes(tempFilePath))
            Util.File:DeleteFile(tempFilePath)
        end
        Util.File:WriteBytes(self.savePath, data:ToArray())

        -- print(data:ToArray().Length)
        if (cb ~= nil) then
            cb(self.tempSize)
        end
    end
    local one_cb = function(index, size)
        downCount = downCount + 1
        if (downCount >= self.threadCount) then
            all_cb()
        end
    end
    local one_downloading = function(index, size, count, rsize)
        self.tempSize = self.tempSize + rsize
        if (downloading ~= nil) then
            downloading(self.tempSize, self.size)
        end
    end
    for index = 1, self.threadCount do
        self:_downloadOne(index, one_cb, one_downloading)
    end
end
function DownloadFile:_downloadOne(index, cb, downloading)
    local size = self.sizes[index]
    local tempFilePath = self.tempFilePaths[index]
    Util.Http:Download(
        self.url,
        tempFilePath,
        function(size)
            if (cb ~= nil) then
                cb(index, tonumber(tostring(size)))
            end
        end,
        function(size, count, rsize)
            if (downloading ~= nil) then
                downloading(index, tonumber(tostring(size)), tonumber(tostring(count)), tonumber(tostring(rsize)))
            end
        end,
        self.error,
        size.min,
        size.max
    )
end

-- 异步获取文件大小
function DownloadFile:getFileSizeAsyn(cb, error)
    CSHttpUtil:GetDownloadSizeAsyn(
        self.url,
        function(size)
            if (cb ~= nil) then
                -- 此处需要转换一下 C#的long转lua中的number
                cb(tonumber(tostring(size)))
            end
        end,
        function(ex)
            if (error ~= nil) then
                error(ex)
            end
        end
    )
end

-- 分割文件尺寸 用于多线程并行下载
function DownloadFile:splitFileSize(size, count)
    local arr = {}
    for i = 1, count do
        table.insert(arr, {min = math.ceil(size * (i - 1) / count), max = math.ceil(size * i / count) - 1})
    end
    return arr
end

return DownloadFile
